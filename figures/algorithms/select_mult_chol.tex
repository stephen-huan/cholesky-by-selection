\begin{algorithmic}[1]
  \REQUIRE \( \vec{x}_\Train, \vec{x}_\Pred, \K(\cdot, \cdot), s \)
  \ENSURE \( \I \)

  \STATE \( N \gets \card{\vec{x}_\Train} \)
  \STATE \( m \gets \card{\vec{x}_\Pred} \)
  \STATE \(
    \vec{x} \gets
    \begin{pmatrix}
      \vec{x}_\Train \\
      \vec{x}_\Pred
    \end{pmatrix}
  \)
  \STATE \( \I \gets \emptyset \)
  \STATE \( -\I \gets \{ 1, \dotsc, N \} \)
  \STATE \( L \gets \vec{0}^{(N + m) \times s} \)
  \STATE \( L_\Pred \gets \vec{0}^{(N + m) \times (s + m)} \)
  \STATE \(
    \diag(\CM_{\Train, \Train \mid \I}) \gets
    \diag(K(\vec{x}_\Train, \vec{x}_\Train))
  \)
  \STATE \(
    \diag(\CM_{\Train, \Train \mid \I, \Pred}) \gets
    \diag(\CM_{\Train, \Train \mid \I})
  \)
  \FOR{\( i \in \{ 1, \dotsc, m \} \)}
    \STATE Update \( L_\Pred \) and \( \diag(\CM_{\Train, \Train
      \mid \I, \Pred}) \) with \( k = N + i \) by \cref{alg:chol_update}.
  \ENDFOR
  \WHILE{\( \card{-\I} > 0 \) and \( \card{\I} < s \)}
    \STATE \(
      k \gets \min_{j \in -\I}
      \frac{\CM_{j, \Pred \mid \I}}{\CM_{j, j \mid \I}}
    \)
    \STATE \( \I \gets \I \cup \{ k \} \)
    \STATE \( -\I \gets -\I - \{ k \} \)
    \STATE \( i \gets \card{\I} \)
    \STATE Update \( L \) and \( \diag(\CM_{\Train, \Train
      \mid \I}) \) \\ by \cref{alg:chol_update}.
    \STATE Update \( L_\Pred \) and \( \diag(\CM_{\Train, \Train
      \mid \I, \Pred}) \) with \( i = i + m \) by \cref{alg:chol_update}.
  \ENDWHILE
  \RETURN \( \I \)
\end{algorithmic}
